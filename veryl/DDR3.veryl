interface ddr3_phys_if#(
    param DATA_WIDTH = 32,
){
    var odt   : logic;
    var cke   : logic;
    var we_n  : logic;
    var cas_n : logic;
    var ras_n : logic;
    var cs_n  : logic;
    var rst_n : logic;
    var clk_p : logic;
    var clk_n : logic;
    var a     : logic<16>;
    var ba    : logic<3>;
    var dm    : logic<DATA_WIDTH/8>;
    var dq    : logic<DATA_WIDTH>;
    var dqs_p : logic<DATA_WIDTH/8>;
    var dqs_n : logic<DATA_WIDTH/8>;

    modport Phys {
        odt   : output,
        cke   : output,
        we_n  : output,
        cas_n : output,
        ras_n : output,
        cs_n  : output,
        rst_n : output,
        clk_p : output,
        clk_n : output,
        a     : output,
        ba    : output,
        dm    : output,
        dq    : inout,
        dqs_p : inout,
        dqs_n : inout,
    }
}


proto package proto_ddr3_cfg{
    const tCK   : u32;
    const tCKE  : u32;
    const tFAW  : u32;
    const tRAS  : u32;
    const tRCD  : u32;
    const tREFI : u32;
    const tRFC  : u32;
    const tRP   : u32;
    const tPRD  : u32;
    const tWTR  : u32;

    const AL  : u32;
    const CL  : u32;
    const CAS : u32;
}

interface ddr3_csr_if{
    
    
    modport Phys {

    }
}


module ddr3_phys_burst8::<cfg : proto_ddr3_cfg>#(
    param DATA_WIDTH = 32,
)(
    sys_clk : input clock,
    rst_n   : input reset,
    ddr3_clk : input clock,
    phys_if : modport ddr3_phys_if::Phys,
){
    const DQS_BITS : u32 = DATA_WIDTH/8;

    // DDR3 differential clock output
    inst ddr3_clk_emu_lvds_obuf : ELVDS_OBUF(
        .I#clock   : ddr3_clk,

        .IO  : phys_if.clk_p,
        .IOB : phys_if.clk_n,
    );

    for i in 0..DQS_BITS : DQS{
        inst : ddr3_dq_dqs(
            sys_clk,
            rst,
            ddr3_clk,

            dqs : phys_if.dqs[i],
            dm  : phys_if.dm[i*8+7 : i*8],
        );
    }
}

module ddr3_dq_dqs(
    sys_clk  : input clock,
    rst      : input reset,
    ddr3_clk : input clock,

    dqs : inout logic,
    dm  : inout logic<8>,
){
    var dll_stop : logic;
    var dll_lock : logic;
    var dll_update_ctnl : logic;
    var dll_step : logic<8>;
    
    var DQS_in  : logic;
    var DQS_out : logic;
    var DQS_out_en : logic;
    
    var dqsr90_clk  : clock;
    var dqsw270_clk : clock;
    var dqsw0_clk   : clock;

    var dqs_hold : logic;
    var dqs_read_en : logic<4>;
    var dqs_read_clk_sel : logic<3>;
    var dqs_reset : logic;
    var dqs_rpoint : logic<3>;
    var dqs_wpoint : logic<3>;
    var dqs_rflag : logic;
    var dqs_wflag : logic;
    var dqs_rvalid : logic;
    var dqs_rburst : logic;

    inst ddr_dll : DDRDLL#(
        DLL_FORCE : 1'b0, // forced delay step or lock control (0 to normal mode)
        CODESCAL : 3'b000, // phase shift config for DDRLL (000 to 101 degree)
        SCAL_EN : "false", // phase shift control (false to 90 degree, true to use CODESCAL)
        DIV_SEL : 1'b0, // lock mode (0 to nomal, 1 to fast-lock-mode)
    )(
        // inputs
        CLKIN#clock : ddr3_clk,
        RESET    : rst, // 1 to reset
        STOP     : dll_stop, // clock control (0 to ennable)
        UPDNCNTL : dll_update_ctnl, // update control (0 to update, 1 to keep)
        // outputs
        LOCK     : dll_lock, // 1 to lock
        STEP     : dll_step, // delay step
    );

    inst dqs_emu_lvds_iobuf : ELVDS_IOBUF(
        .I   : DQS_in,
        .OEN : DQS_out_en,
        .O   : DQS_out,

        .IO  : dqs_p[i],
        .IOB : dqs_n[i],
    );

    inst dqs : DQS#(
        FIFO_MODE_SEL : 1'b0, // FIFO-mode (0 to DDR 1 to GDDR)
        RD_PNTR : 3'b000, // FIFO read pointer setting
        DQS_MODE : "X2_DDR3", // MDDR select (DQS mode)
        HWL : "false", // Updata0/1 time relation control
    )(
        // inputs
        DLLSTEP : dll_step, // DQS delay control
        DQSIN   : DQS_in,
        FCLK#clock : ddr3_clk, // fast clock
        HOLD    : dqs_hold,
        PCLK    : sys_clk, // primary clock
        RDIR    : 1'd1, // Adjusts the delay direction of read (1 to decrease delay)
        RLOADN  : 1'd0, // asynchronous reset the final delay (active low)
        RMOVE   : 1'd0, // Changes the delay step of DDR read on falling edge, once per pulse.
        WDIR    : 1'd1, // Adjusts the delay direction of write (1 to decrease)
        WLOADN  : 1'd0, // Resets the final delay step of DDR write (active low)
        WMOVE   : 1'd0, // Changes the delay step of DDR write on falling edge, once per pulse.
        WSTEP   : 8'd0, // DDR write equalization delay control.
        READ    : dqs_read_en, // Read signal for DDR read mode
        RCLKSEL : dqs_read_clk_sel, // Select read clock source and polarity control 
        RESET   : rst, // DQS reset control (active high)

        // outputs
        RPOINT  : dqs_rpoint, // FIFO read pointer for RADDR in IDES8_MEM
        WPOINT  : dqs_wpoint, // FIFO write pointer for WADDR in IDES8_MEM
        DQSW0#clock   : dqsw0_clk, // SCLK/ECLK phase shifted or delayed by 0 degree for TCLK in OSER8_MEM
        DQSW270#clock : dqsw270_clk, // SCLK/ECLK phase shifted or delayed by 0 degree for TCLK in OSER8_MEM
        DQSR90#clock  : dqsr90_clk, // DQSI phase shifted or delayed by 90 degree for ICLK in IDES8_MEM
        RFLAG   : dqs_rflag, // indicate the under-flow or over-flow of read
        WFLAG   : dqs_wflag, // indicate the under-flow or over-flow of write
        RVALID  : dqs_rvalid, // Data Valid Flag in READ mode
        RBURST  : dqs_rburst, // READ burst detect
    );

    // Data bus
    for i : in 0..8 : DDR_SERDES {
        var IOBUF_in  : logic;
        var IOBUF_out : logic;
        var IOBUF_out_en : logic;
        var out_delay_df : logic;
        var IODELAY_out : logic;
        var in_delay_df : logic;
        var IODELAY_in : logic;

        
        inst $sv::IDES8_MEM#(
            GSREN : "false" // global reset GSR
            LSREN : "false" // local reset GSR
        )(
            D : IOBUF_in,
            ICLK : dqsr90_clk,
            FCLK : ddr3_clk,
            PCLK : sys_clk, // 1/4 FCLK = 1/4 ICLK
            WADDR : dqs_wpoint,
            RADDR : dqs_rpoint,
            CALIB,
            RESET : rst,
            Q0,
            Q1,
            Q2,
            Q3,
            Q4,
            Q5,
            Q6,
            Q7,
        );
        inst $sv::OSER8_MEM#(
            GSREN : "false", // global reset GSR
            GSREN : "false", // local reset GSR
            TXCLK_POL : 1'b0, // clock polarity of IOBUF_out_en (posedge)
            TCLK_SOURCE : "DQSW", // from dqsw0
            HWL : "false", // d_up1 is one cycle ahead of d_up0 
        )(
            Q0 : IOBUF_out,
            Q1 : IOBUF_out_en,
            D0,
            D1,
            D2,
            D3,
            D4,
            D5,
            D6,
            D7,
            TX0 : 1'b0,
            TX1 : 1'b0,
            TX2 : 1'b0,
            TX3 : 1'b0,
            TCLK#clock : dqsw0_clk, // DQS clock
            FCLK#clock : ddr3_clk, // fast clock
            PCLK#clock : sys_clk, // primary clock
            RESET : rst, // active high
        );

        inst out_delay : $sv::IODELAY#(
            C_STATIC_DLY : 0, // static delay (0~127, 1step=22ps)
        )(
            // inputs
            DI : IOBUF_out,
            SDTAP : 0, // 0 to static delay
            SETN  : 0, // delay (0 to increase, 1 to decrease)
            VALUE : 0, // change delay when posedge 
            // outputs
            DF : out_delay_df,// data over-flow or under-flow
            DO : IODELAY_out,
        );

        inst in_delay : $sv::IODELAY#(
            C_STATIC_DLY : 0, // static delay (0~127, 1step=22ps)
        )(
            // inputs
            DI : IODELAY_in,
            SDTAP : 0, // 0 to static delay
            SETN  : 0, // delay (0 to increase, 1 to decrease)
            VALUE : 0, // change delay when posedge 
            // outputs
            DF : out_delay_df,// data over-flow or under-flow
            DO : IOBUF_out,
        );

        inst ddr_data_iobuf : $sv::IOBUF(
            I   : IODELAY_in,
            OEN : IOBUF_out_enable,
            O   : IODELAY_out,

            IO  : phys_if.dq[i],
        );
    }
}